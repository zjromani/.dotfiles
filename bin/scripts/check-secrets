#!/usr/bin/env bash
set -euo pipefail

# Pre-commit hook: scan staged files for common secret patterns.
# Exit 1 (blocking commit) if any matches are found.

RED='\033[0;31m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

declare -a PATTERNS=(
  '[aA][pP][iI][_-]?[kK][eE][yY]\s*=\s*["'"'"']?[A-Za-z0-9]{16,}'
  '[sS][eE][cC][rR][eE][tT]\s*=\s*["'"'"']?[A-Za-z0-9]{16,}'
  '[pP][aA][sS][sS][wW][oO][rR][dD]\s*=\s*["'"'"']?[^\s]{8,}'
  'AKIA[0-9A-Z]{16}'
  'aws_secret_access_key\s*=\s*[A-Za-z0-9/+=]{40}'
  '-----BEGIN (RSA|EC|OPENSSH|DSA) PRIVATE KEY'
  'gh[ps]_[A-Za-z0-9]{36,}'
  'sk-ant-[A-Za-z0-9_-]{32,}'
  'sk-[A-Za-z0-9]{32,}'
  'xox[baprs]-[A-Za-z0-9-]{10,}'
)

found=0

while IFS= read -r file; do
  # Skip deleted files
  if ! git ls-files --error-unmatch "$file" &>/dev/null 2>&1 && \
     git diff --cached --name-only --diff-filter=D | grep -qF "$file"; then
    continue
  fi

  # Skip binary files by checking git's own mime detection
  if git diff --cached --numstat -- "$file" | grep -qE '^-\s+-\s+'; then
    continue
  fi

  # Get staged content
  staged_content=$(git show ":$file" 2>/dev/null) || continue

  for pattern in "${PATTERNS[@]}"; do
    matches=$(echo "$staged_content" | grep -nPo "$pattern" 2>/dev/null || true)
    if [ -n "$matches" ]; then
      if [ "$found" -eq 0 ]; then
        echo -e "${RED}[check-secrets] Potential secrets detected â€” commit blocked${NC}" >&2
        echo "" >&2
      fi
      found=1
      while IFS= read -r match; do
        lineno=$(echo "$match" | cut -d: -f1)
        content=$(echo "$match" | cut -d: -f2-)
        preview="${content:0:40}"
        echo -e "  ${YELLOW}${file}:${lineno}${NC}  ${preview}..." >&2
      done <<< "$matches"
    fi
  done
done < <(git diff --cached --name-only --diff-filter=d)

if [ "$found" -ne 0 ]; then
  echo "" >&2
  echo "To bypass (only if you're sure): git commit --no-verify" >&2
  exit 1
fi

exit 0
